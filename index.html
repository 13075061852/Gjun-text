<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>读取Excel文件数据</title>
    <style>
        /* 页面基本样式设置 */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 100%;
            margin: 0 auto;
            padding: 20px;
            overflow: auto; /* 页面水平和垂直滚动 */
            background-color: #f8f9fa;
        }
    
        /* 控制区域容器 */
        .control-panel {
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            padding: 25px;
            margin-bottom: 25px;
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        /* 文件选择区域 */
        .file-selection {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 15px;
        }
        
        .file-selection label {
            font-weight: 600;
            color: #34495e;
            margin-right: 10px;
        }
        
        #fileInput {
            padding: 10px;
            width: 180px;
            border: 2px dashed #3498db;
            border-radius: 6px;
            background-color: #f8f9fa;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        #readBtn {
            padding: 15px 20px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.3s;
        }
        
        #readBtn:hover {
            background-color: #2980b9;
        }
        
        /* 搜索区域 */ 
        #searchInput {
            padding: 14px 15px;
            min-width: 250px;
            border: 2px solid #3498db;
            border-radius: 6px;
            font-size: 16px;
            transition: border-color 0.3s;
        }
        
        #searchInput:focus {
            outline: none;
            border-color: #2980b9;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
        }
        
        .search-hint {
            margin-top: 15px;
            font-size: 14px;
            color: #7f8c8d;
            font-style: italic;
        }
        
        table {
            border-collapse: collapse;
            width: auto; /* 根据内容自动调整宽度 */
            margin: 20px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            border-radius: 8px;
            overflow: hidden;
            table-layout: auto; /* 自动表格布局，允许单元格根据内容调整宽度 */
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px 15px;
            text-align: center; /* 水平居中 */
            vertical-align: middle; /* 垂直居中 */
            white-space: nowrap; /* 不换行 */
            overflow: visible; /* 允许内容溢出 */
            text-overflow: clip; /* 不显示省略号，显示完整内容 */
            min-width: 80px; /* 设置最小宽度 */
        }
        thead th {
            background-color: #3498db;
            color: white;
            font-weight: bold;
            text-align: center;
            position: sticky; /* 固定表头 */
            top: 0; /* 固定在顶部 */
            z-index: 10; /* 确保表头在其他元素之上 */
        }
        
        /* 确保表头在容器内也能固定 */
        .table-wrapper thead th {
            position: sticky !important;
            top: 0 !important;
            background-color: #3498db; /* 确保背景色不被覆盖 */
        }
        
        /* 额外确保表头固定 */
        table thead {
            position: sticky;
            top: 0;
        }
        
        /* 确保表格容器正确设置 */
        .table-wrapper {
            overflow: auto;
            position: relative;
        }
        
        /* 最终确保表头固定 */
        .table-wrapper table thead th {
            position: sticky !important;
            top: 0 !important;
        }
        td {
            background-color: #f9f9f9;
        }
        tr:nth-child(even) td {
            background-color: #f2f2f2;
        }
        tr:hover td {
            background-color: #e1f0fa;
        }
        .error {
            color: #e74c3c;
            background-color: #fdeded;
            padding: 12px;
            border-radius: 6px;
            border-left: 4px solid #e74c3c;
            margin: 15px 0;
        }
        .success {
            color: #27ae60;
            background-color: #e8f7f0;
            padding: 12px;
            border-radius: 6px;
            border-left: 4px solid #27ae60;
            margin: 15px 0;
        }
        .merged-data-table {
            margin-top: 40px;
            width: 100%;
        }
        .merged-data-table h2 {
            color: #333;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        
        /* 响应式设计 */
        @media (max-width: 768px) {
            .control-panel {
                padding: 15px;
            }
            
            table {
                font-size: 14px;
            }
            th, td {
                padding: 8px 10px;
                min-width: 60px;
            }
        }
        
        /* 标签页样式 */
        .tab-container {
            margin: 20px 0;
            width: 100%;
        }
        .tab-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-bottom: 10px;
        }
        .tab-button {
            padding: 12px 20px;
            background-color: #f1f8ff;
            border: none;
            cursor: pointer;
            border-radius: 6px 6px 0 0;
            transition: all 0.3s;
            white-space: nowrap;
            font-weight: 500;
        }
        .tab-button:hover {
            background-color: #d1e7ff;
        }
        .tab-button.active {
            background-color: #3498db;
            color: white;
        }
        .tab-content {
            display: none;
            width: 100%;
        }
        .tab-content.active {
            display: block;
        }
        
        /* 滚动条容器 */
        .table-wrapper {
            overflow-x: auto; /* 只允许水平滚动 */
            overflow-y: visible; /* 禁用垂直滚动 */
            margin: 20px 0;
            width: 100%;
            position: relative; /* 确保容器定位上下文正确 */
        }
        
        /* 页面内容容器 */
        .content-container {
            width: 100%;
            overflow: auto;
        }
        
        /* 高亮显示搜索结果 */
        .highlight {
            background-color: #ffeb3b;
            font-weight: bold;
        }
        
        /* 平均值特殊颜色标注 */
        .average-value {
            color: #e91e63;
            font-weight: bold;
        }
        
        /* 参数值方括号间隔 */
        .param-value {
            margin-right: 2px;
        }
        
        /* 分页控件样式 */
        .pagination-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 20px 0;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 8px;
            flex-wrap: wrap;
        }
        
        .pagination-info {
            margin-right: 20px;
        }
        
        .page-size-select {
            padding: 5px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: white;
        }
        
        .pagination-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .page-btn {
            padding: 8px 12px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        .page-btn:hover:not(:disabled) {
            background-color: #2980b9;
        }
        
        .page-btn:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }
        
        .page-info {
            font-weight: 500;
            color: #34495e;
        }
        
        .page-info span {
            font-weight: bold;
            color: #3498db;
        }
    </style>
</head>
<body>
    <!-- 控制面板 -->
    <div class="control-panel">
        <!-- 文件选择区域 -->
        <div class="file-selection">
            <input type="file" id="fileInput" accept=".xlsx, .xls">
            <button id="readBtn">读取文件</button>
        </div>
        
        <!-- 搜索区域 -->
            <div class="search-box">
                <input type="text" id="searchInput" placeholder="输入型号或批次关键字进行搜索">
            </div>
    </div>
    
    <!-- 结果提示信息显示区域 -->
    <div id="result"></div>
    
    <!-- 表格数据显示区域 -->
    <div id="tableContainer"></div>

    <!-- 引入SheetJS库用于处理Excel文件 -->
    <script src="https://cdn.bootcdn.net/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    
    <script>
        // 页面加载完成后检查XLSX库是否加载成功
        window.addEventListener('load', function() {
            if (typeof XLSX === 'undefined') {
                document.getElementById('result').innerHTML = '<p class="error">Excel处理库加载失败，请检查网络连接后刷新页面</p>';
            }
        });
        
        // 为读取按钮添加点击事件监听器
        document.getElementById('readBtn').addEventListener('click', handleFile);
        
        // 为搜索框添加实时输入事件监听器
        document.getElementById('searchInput').addEventListener('input', handleSearch);
        
        // 存储原始数据用于搜索
        let originalMergedData = {};
        
        // 分页相关变量
        let currentPage = {}; // 当前页码
        let pageSize = {};   // 每页显示条数
        let totalPages = {}; // 总页数
        
        // 当前激活的工作表
        let activeSheetName = null;
        
        /**
         * 处理用户选择的Excel文件
         * 1. 检查是否选择了文件
         * 2. 使用FileReader读取文件
         * 3. 解析Excel文件并显示结果
         */
        function handleFile() {
            // 获取文件输入元素和选中的文件
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];
            
            // 检查用户是否选择了文件
            if (!file) {
                document.getElementById('result').innerHTML = '<p class="error">请选择一个Excel文件</p>';
                return;
            }
            
            // 创建文件读取器对象
            const reader = new FileReader();
            
            // 文件读取成功的回调函数
            reader.onload = function(e) {
                try {
                    // 将文件数据转换为Uint8Array格式
                    const data = new Uint8Array(e.target.result);
                    console.log(data);
                    
                    // 使用SheetJS读取Excel工作簿
                    const workbook = XLSX.read(data, {type: 'array'});
                    console.log(workbook);
                    
                    // 将工作簿转换为JSON格式
                    const jsonData = convertWorkbookToJSON(workbook);
                    
                    // 在浏览器控制台打印JSON数据
                    console.log('Excel数据 (JSON格式):', jsonData);
                    
                    // 详细遍历每个工作表中的对象
                    traverseJSONData(jsonData);
                
                } catch (error) {
                    // 处理文件读取或解析错误
                    document.getElementById('result').innerHTML = '<p class="error">读取文件时出错: ' + error.message + '</p>';
                }
            };
            
            // 文件读取失败的回调函数
            reader.onerror = function() {
                document.getElementById('result').innerHTML = '<p class="error">文件读取失败</p>';
            };
            
            // 以ArrayBuffer格式读取文件内容
            reader.readAsArrayBuffer(file);
        }
        
        /**
         * 处理实时搜索功能 - 对型号和批次进行模糊查询
         */
        function handleSearch() {
            const searchTerm = document.getElementById('searchInput').value.trim();
            
            // 如果没有原始数据，直接返回
            if (!originalMergedData || Object.keys(originalMergedData).length === 0) {
                return;
            }
            
            // 如果搜索框为空，显示所有数据
            if (!searchTerm) {
                // 重置分页数据，但保留pageSize设置
                for (const sheetName in originalMergedData) {
                    currentPage[sheetName] = 1; // 重置到第一页
                    if (pageSize[sheetName] === undefined) {
                        pageSize[sheetName] = 15; // 只有当pageSize尚未设置时才设置默认值
                    }
                    totalPages[sheetName] = Math.ceil(originalMergedData[sheetName].length / pageSize[sheetName]);
                }
                renderMergedDataBelow(originalMergedData);
                // 清除结果提示
                document.getElementById('result').innerHTML = '';
                return;
            }
            
            // 创建搜索结果的副本 - 在所有工作表中搜索
            const filteredData = {};
            
            // 在所有工作表中搜索
            for (const sheetName in originalMergedData) {
                const sheetData = originalMergedData[sheetName];
                filteredData[sheetName] = [];
                
                // 过滤数据 - 只在型号和批次字段中搜索
                sheetData.forEach(row => {
                    // 检查型号和批次字段是否包含搜索词（不区分大小写）
                    const model = row['型号'] ? row['型号'].toString() : '';
                    const batch = row['批次'] ? row['批次'].toString() : '';
                    
                    const modelMatch = model.toLowerCase().includes(searchTerm.toLowerCase());
                    const batchMatch = batch.toLowerCase().includes(searchTerm.toLowerCase());
                    
                    // 如果满足搜索条件，则添加到结果中
                    if (modelMatch || batchMatch) {
                        filteredData[sheetName].push(row);
                    }
                });
            }
            
            // 显示当前激活工作表的搜索结果数量
            let resultMessage = '';
            if (activeSheetName && filteredData[activeSheetName]) {
                const currentSheetResults = filteredData[activeSheetName].length;
                if (currentSheetResults > 0) {
                    resultMessage = `<p class="success">在工作表 "${activeSheetName}" 中找到 ${currentSheetResults} 条匹配记录</p>`;
                } else {
                    resultMessage = `<p class="error">在工作表 "${activeSheetName}" 中未找到匹配的记录</p>`;
                }
            } else {
                // 如果没有激活的工作表，显示总结果
                let totalResults = 0;
                for (const sheetName in filteredData) {
                    totalResults += filteredData[sheetName].length;
                }
                
                if (totalResults > 0) {
                    resultMessage = `<p class="success">找到 ${totalResults} 条匹配记录</p>`;
                } else {
                    resultMessage = '<p class="error">未找到匹配的记录</p>';
                }
            }
            
            const resultElement = document.getElementById('result');
            resultElement.innerHTML = resultMessage;
            
            // 重置分页数据
            initPaginationData(filteredData);
            
            // 重新渲染表格
            renderMergedDataBelow(filteredData);
        }
        
        /**
         * 初始化分页数据
         * @param {Object} data - 数据对象
         */
        function initPaginationData(data) {
            for (const sheetName in data) {
                currentPage[sheetName] = 1; // 默认第一页
                // 只有当pageSize尚未设置时才设置默认值
                if (pageSize[sheetName] === undefined) {
                    pageSize[sheetName] = 10;   // 默认每页10条
                }
                totalPages[sheetName] = Math.ceil(data[sheetName].length / pageSize[sheetName]);
            }
        }
        
        /**
         * 计算数组的平均值
         * @param {Array} arr - 数字数组
         * @returns {number} 平均值
         */
        function calculateAverage(arr) {
            if (!Array.isArray(arr) || arr.length === 0) {
                return 0;
            }
            
            // 过滤出数字值
            const numbers = arr.filter(value => !isNaN(parseFloat(value))).map(value => parseFloat(value));
            
            if (numbers.length === 0) {
                return 0;
            }
            
            const sum = numbers.reduce((acc, num) => acc + num, 0);
            return sum / numbers.length;
        }
        
        /**
         * 将Excel工作簿转换为JSON格式
         * @param {Object} workbook - Excel工作簿对象
         * @returns {Object} 包含所有工作表数据的JSON对象
         */
        function convertWorkbookToJSON(workbook) {
            const result = {};
            
            // 遍历所有工作表名称
            workbook.SheetNames.forEach(function(sheetName) {
                const worksheet = workbook.Sheets[sheetName];
                // 将工作表转换为JSON数据（使用默认的header设置，这样会包含列名）
                result[sheetName] = XLSX.utils.sheet_to_json(worksheet);
            });
            
            return result;
        }
        
        /**
         * 遍历并打印JSON数据到控制台
         * @param {Object} jsonData - 包含Excel数据的JSON对象
         */
        function traverseJSONData(jsonData) {     
            let newObj = {}       
            // 遍历每个工作表
            for (const sheetName in jsonData) {
                newObj[sheetName] = []

                console.log(`\n工作表名称: ${sheetName}`);
                const sheetData = jsonData[sheetName];        
                // 遍历工作表中的每一行数据
                for (let index = 0; index < sheetData.length; index++) {
                    const row = sheetData[index];
                    if (row['型号']) {
                        // 创建一个新的合并对象，包含当前行和往后两条数据的所有参数
                        const mergedRow = {};
                        
                        // 合并当前行数据（过滤空值和非数字类型值，除了型号和批次）
                        for (const key in row) {
                            if (row[key] !== null && row[key] !== undefined && row[key] !== '') {
                                // 检查是否为型号或批次字段，如果是则不过滤
                                if (key === '型号' || key === '批次') {
                                    // 处理字段名相似的情况，将它们合并到同一个数组中
                                    let baseKey = key;
                                    // 检查是否有带_数字后缀的字段名
                                    const suffixMatch = key.match(/^(.*)_([0-9]+)$/);
                                    if (suffixMatch) {
                                        baseKey = suffixMatch[1];
                                    }
                                    
                                    // 查找是否已存在基础字段名
                                    let existingKey = null;
                                    for (const existingField in mergedRow) {
                                        const existingSuffixMatch = existingField.match(/^(.*)_([0-9]+)$/);
                                        let existingBaseKey = existingField;
                                        if (existingSuffixMatch) {
                                            existingBaseKey = existingSuffixMatch[1];
                                        }
                                            
                                        if (existingBaseKey === baseKey) {
                                            existingKey = existingField;
                                            break;
                                        }
                                    }
                                    
                                    // 如果字段已存在，则转换为数组并添加新值
                                    if (existingKey) {
                                        if (!Array.isArray(mergedRow[existingKey])) {
                                            mergedRow[existingKey] = [mergedRow[existingKey]];
                                        }
                                        mergedRow[existingKey].push(row[key]);
                                    } else {
                                        mergedRow[key] = row[key];
                                    }
                                } else {
                                    // 对于其他字段，只保留数字类型的值
                                    const value = row[key];
                                    if (!isNaN(parseFloat(value)) && isFinite(value)) {
                                        // 处理字段名相似的情况，将它们合并到同一个数组中
                                        let baseKey = key;
                                        // 检查是否有带_数字后缀的字段名
                                        const suffixMatch = key.match(/^(.*)_([0-9]+)$/);
                                        if (suffixMatch) {
                                            baseKey = suffixMatch[1];
                                        }
                                        
                                        // 查找是否已存在基础字段名
                                        let existingKey = null;
                                        for (const existingField in mergedRow) {
                                            const existingSuffixMatch = existingField.match(/^(.*)_([0-9]+)$/);
                                            let existingBaseKey = existingField;
                                            if (existingSuffixMatch) {
                                                existingBaseKey = existingSuffixMatch[1];
                                            }
                                                
                                            if (existingBaseKey === baseKey) {
                                                existingKey = existingField;
                                                break;
                                            }
                                        }
                                        
                                        // 如果字段已存在，则转换为数组并添加新值
                                        if (existingKey) {
                                            if (!Array.isArray(mergedRow[existingKey])) {
                                                mergedRow[existingKey] = [mergedRow[existingKey]];
                                            }
                                            mergedRow[existingKey].push(parseFloat(value));
                                        } else {
                                            mergedRow[key] = parseFloat(value);
                                        }
                                    }
                                }
                            }
                        }
                        
                        // 合并下一行数据（过滤空值和非数字类型值，除了型号和批次）
                        if (index + 1 < sheetData.length) {
                            const nextRow = sheetData[index + 1];
                            for (const key in nextRow) {
                                if (nextRow[key] !== null && nextRow[key] !== undefined && nextRow[key] !== '') {
                                    // 检查是否为型号或批次字段，如果是则不过滤
                                    if (key === '型号' || key === '批次') {
                                        // 处理字段名相似的情况，将它们合并到同一个数组中
                                        let baseKey = key;
                                        // 检查是否有带_数字后缀的字段名
                                        const suffixMatch = key.match(/^(.*)_([0-9]+)$/);
                                        if (suffixMatch) {
                                            baseKey = suffixMatch[1];
                                        }
                                        
                                        // 查找是否已存在基础字段名
                                        let existingKey = null;
                                        for (const existingField in mergedRow) {
                                            const existingSuffixMatch = existingField.match(/^(.*)_([0-9]+)$/);
                                            let existingBaseKey = existingField;
                                            if (existingSuffixMatch) {
                                                existingBaseKey = existingSuffixMatch[1];
                                            }
                                            
                                            if (existingBaseKey === baseKey) {
                                                existingKey = existingField;
                                                break;
                                            }
                                        }
                                        
                                        // 如果字段已存在，则转换为数组并添加新值
                                        if (existingKey) {
                                            if (!Array.isArray(mergedRow[existingKey])) {
                                                mergedRow[existingKey] = [mergedRow[existingKey]];
                                            }
                                            mergedRow[existingKey].push(nextRow[key]);
                                        } else {
                                            mergedRow[key] = nextRow[key];
                                        }
                                    } else {
                                        // 对于其他字段，只保留数字类型的值
                                        const value = nextRow[key];
                                        if (!isNaN(parseFloat(value)) && isFinite(value)) {
                                            // 处理字段名相似的情况，将它们合并到同一个数组中
                                            let baseKey = key;
                                            // 检查是否有带_数字后缀的字段名
                                            const suffixMatch = key.match(/^(.*)_([0-9]+)$/);
                                            if (suffixMatch) {
                                                baseKey = suffixMatch[1];
                                            }
                                            
                                            // 查找是否已存在基础字段名
                                            let existingKey = null;
                                            for (const existingField in mergedRow) {
                                                const existingSuffixMatch = existingField.match(/^(.*)_([0-9]+)$/);
                                                let existingBaseKey = existingField;
                                                if (existingSuffixMatch) {
                                                    existingBaseKey = existingSuffixMatch[1];
                                                }
                                                
                                                if (existingBaseKey === baseKey) {
                                                    existingKey = existingField;
                                                    break;
                                                }
                                            }
                                            
                                            // 如果字段已存在，则转换为数组并添加新值
                                            if (existingKey) {
                                                if (!Array.isArray(mergedRow[existingKey])) {
                                                    mergedRow[existingKey] = [mergedRow[existingKey]];
                                                }
                                                mergedRow[existingKey].push(parseFloat(value));
                                            } else {
                                                mergedRow[key] = parseFloat(value);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        
                        // 合并下两行数据（过滤空值和非数字类型值，除了型号和批次）
                        if (index + 2 < sheetData.length) {
                            const nextNextRow = sheetData[index + 2];
                            for (const key in nextNextRow) {
                                if (nextNextRow[key] !== null && nextNextRow[key] !== undefined && nextNextRow[key] !== '') {
                                    // 检查是否为型号或批次字段，如果是则不过滤
                                    if (key === '型号' || key === '批次') {
                                        // 处理字段名相似的情况，将它们合并到同一个数组中
                                        let baseKey = key;
                                        // 检查是否有带_数字后缀的字段名
                                        const suffixMatch = key.match(/^(.*)_([0-9]+)$/);
                                        if (suffixMatch) {
                                            baseKey = suffixMatch[1];
                                        }
                                        
                                        // 查找是否已存在基础字段名
                                        let existingKey = null;
                                        for (const existingField in mergedRow) {
                                            const existingSuffixMatch = existingField.match(/^(.*)_([0-9]+)$/);
                                            let existingBaseKey = existingField;
                                            if (existingSuffixMatch) {
                                                existingBaseKey = existingSuffixMatch[1];
                                            }
                                            
                                            if (existingBaseKey === baseKey) {
                                                existingKey = existingField;
                                                break;
                                            }
                                        }
                                        
                                        // 如果字段已存在，则转换为数组并添加新值
                                        if (existingKey) {
                                            if (!Array.isArray(mergedRow[existingKey])) {
                                                mergedRow[existingKey] = [mergedRow[existingKey]];
                                            }
                                            mergedRow[existingKey].push(nextNextRow[key]);
                                        } else {
                                            mergedRow[key] = nextNextRow[key];
                                        }
                                    } else {
                                        // 对于其他字段，只保留数字类型的值
                                        const value = nextNextRow[key];
                                        if (!isNaN(parseFloat(value)) && isFinite(value)) {
                                            // 处理字段名相似的情况，将它们合并到同一个数组中
                                            let baseKey = key;
                                            // 检查是否有带_数字后缀的字段名
                                            const suffixMatch = key.match(/^(.*)_([0-9]+)$/);
                                            if (suffixMatch) {
                                                baseKey = suffixMatch[1];
                                            }
                                            
                                            // 查找是否已存在基础字段名
                                            let existingKey = null;
                                            for (const existingField in mergedRow) {
                                                const existingSuffixMatch = existingField.match(/^(.*)_([0-9]+)$/);
                                                let existingBaseKey = existingField;
                                                if (existingSuffixMatch) {
                                                    existingBaseKey = existingSuffixMatch[1];
                                                }
                                                
                                                if (existingBaseKey === baseKey) {
                                                    existingKey = existingField;
                                                    break;
                                                }
                                            }
                                            
                                            // 如果字段已存在，则转换为数组并添加新值
                                            if (existingKey) {
                                                if (!Array.isArray(mergedRow[existingKey])) {
                                                    mergedRow[existingKey] = [mergedRow[existingKey]];
                                                }
                                                mergedRow[existingKey].push(parseFloat(value));
                                            } else {
                                                mergedRow[key] = parseFloat(value);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        
                        // 将合并后的对象添加到结果数组中
                        newObj[sheetName].push(mergedRow);
                        
                        // 跳过已处理的行
                        index += 2;
                    }
                }
            }
            console.log(newObj);
            
            // 保存原始数据用于搜索
            originalMergedData = JSON.parse(JSON.stringify(newObj));
            
            // 初始化分页数据
            initPaginationData(newObj);
            
            // 将合并后的数据渲染到页面中（在原有表格下方）
            renderMergedDataBelow(newObj);
        }
        
        /**
         * 在原有表格下方渲染合并后的数据（支持分页）
         * @param {Object} mergedData - 合并后的数据对象
         */
        function renderMergedDataBelow(mergedData) {
            const tableContainer = document.getElementById('tableContainer');
            
            // 清空容器内容，只显示处理后的数据
            tableContainer.innerHTML = '';
            
            // 创建一个新的div来包含合并后的数据
            let mergedDataHTML = '<div id="mergedDataContainer">';
            
            // 创建标签页容器
            mergedDataHTML += '<div class="tab-container">';
            mergedDataHTML += '<div class="tab-buttons">';
            
            // 收集所有工作表名称
            const sheetNames = Object.keys(mergedData);
            
            // 为每个工作表创建标签按钮，并显示匹配记录数量
            sheetNames.forEach((sheetName, index) => {
                // 如果没有记录当前激活的工作表，则默认激活第一个
                const isActive = activeSheetName ? (activeSheetName === sheetName) : (index === 0);
                
                // 获取当前工作表的匹配记录数量
                let matchCount = 0;
                if (originalMergedData && originalMergedData[sheetName]) {
                    // 如果有搜索词，计算匹配数量
                    const searchTerm = document.getElementById('searchInput').value.trim();
                    if (searchTerm) {
                        originalMergedData[sheetName].forEach(row => {
                            const model = row['型号'] ? row['型号'].toString() : '';
                            const batch = row['批次'] ? row['批次'].toString() : '';
                            
                            const modelMatch = model.toLowerCase().includes(searchTerm.toLowerCase());
                            const batchMatch = batch.toLowerCase().includes(searchTerm.toLowerCase());
                            
                            if (modelMatch || batchMatch) {
                                matchCount++;
                            }
                        });
                    } else {
                        // 如果没有搜索词，显示总记录数
                        matchCount = originalMergedData[sheetName].length;
                    }
                }
                
                // 构造按钮文本，包含工作表名称和匹配数量
                const buttonText = `${sheetName} (${matchCount})`;
                mergedDataHTML += `<button class="tab-button ${isActive ? 'active' : ''}" onclick="switchTab('${sheetName}', 'merged')">${buttonText}</button>`;
            });
            
            mergedDataHTML += '</div>';
            mergedDataHTML += '<div class="tab-contents">';
            
            // 为每个工作表创建标签页
            sheetNames.forEach((sheetName, index) => {
                const sheetData = mergedData[sheetName];
                
                // 创建标签内容
                // 如果没有记录当前激活的工作表，则默认激活第一个
                const isContentActive = activeSheetName ? (activeSheetName === sheetName) : (index === 0);
                mergedDataHTML += `<div id="tab-merged-${sheetName}" class="tab-content ${isContentActive ? 'active' : ''}">`;
                
                // 检查工作表是否为空
                if (sheetData.length === 0) {
                    mergedDataHTML += `<h3>工作表: ${sheetName}</h3><p>此工作表中没有数据</p>`;
                } else {
                    // 添加工作表标题
                    mergedDataHTML += `<h3>工作表: ${sheetName}</h3>`;
                    
                    // 计算当前页数据
                    const start = (currentPage[sheetName] - 1) * pageSize[sheetName];
                    const end = start + pageSize[sheetName];
                    const pageData = sheetData.slice(start, end);
                    
                    mergedDataHTML += '<div class="table-wrapper">'; // 添加滚动容器
                    mergedDataHTML += '<table>';
                    
                    // 收集所有唯一的字段名作为表头
                    const allKeys = new Set();
                    sheetData.forEach(row => {
                        Object.keys(row).forEach(key => allKeys.add(key));
                    });
                    
                    // 创建表头
                    mergedDataHTML += '<thead><tr>';
                    allKeys.forEach(key => {
                        // 根据内容长度设置列宽
                        const contentLength = key.length;
                        const estimatedWidth = Math.max(contentLength * 10, 80); // 估算宽度，最小80px
                        mergedDataHTML += `<th style="width: ${estimatedWidth}px;">${key}</th>`;
                    });
                    mergedDataHTML += '</tr></thead>';
                    
                    // 创建表格主体
                    mergedDataHTML += '<tbody>';
                    pageData.forEach((row, index) => {
                        mergedDataHTML += '<tr>';
                        
                        // 为每个字段填充数据
                        allKeys.forEach(key => {
                            const value = row[key];
                            let displayValue = '';
                            
                            if (value === undefined || value === null) {
                                displayValue = '';
                            } else if (Array.isArray(value)) {
                                // 如果是数组，显示原始数据和平均值，使用方括号分隔
                                const average = calculateAverage(value);
                                const bracketValues = value.map(v => `<span class="param-value">[${v}]</span>`).join('');
                                displayValue = `${bracketValues} (<span class="average-value">${average.toFixed(2)}</span>)`;
                            } else {
                                displayValue = value;
                            }
                            
                            // 根据内容长度设置单元格宽度
                            const contentLength = displayValue.length;
                            const estimatedWidth = Math.max(contentLength * 8, 80); // 估算宽度，最小80px
                            mergedDataHTML += `<td style="width: ${estimatedWidth}px;">${displayValue}</td>`;
                        });
                        
                        mergedDataHTML += '</tr>';
                    });
                    mergedDataHTML += '</tbody></table>';
                    mergedDataHTML += '</div>'; // 关闭滚动容器
                    
                    // 添加分页控件
                    mergedDataHTML += '<div class="pagination-container">';
                    mergedDataHTML += '    <div class="pagination-info">';
                    mergedDataHTML += '        <span>每页显示 <select id="pageSizeSelect-' + sheetName + '" class="page-size-select" onchange="changePageSize(\'' + sheetName + '\')">';
                    mergedDataHTML += '            <option value="10" ' + (pageSize[sheetName] == 10 ? 'selected' : '') + '>10</option>';
                    mergedDataHTML += '            <option value="15" ' + (pageSize[sheetName] == 15 ? 'selected' : '') + '>15</option>';
                    mergedDataHTML += '            <option value="20" ' + (pageSize[sheetName] == 20 ? 'selected' : '') + '>20</option>';
                    mergedDataHTML += '            <option value="25" ' + (pageSize[sheetName] == 25 ? 'selected' : '') + '>25</option>';
                    mergedDataHTML += '            <option value="30" ' + (pageSize[sheetName] == 30 ? 'selected' : '') + '>30</option>';
                    mergedDataHTML += '        </select> 条记录</span>';
                    mergedDataHTML += '    </div>';
                    mergedDataHTML += '    <div class="pagination-controls">';
                    mergedDataHTML += '        <button class="page-btn" id="firstPage-' + sheetName + '" onclick="changePage(\'' + sheetName + '\', 1)">首页</button>';
                    mergedDataHTML += '        <button class="page-btn" id="prevPage-' + sheetName + '" onclick="changePage(\'' + sheetName + '\', currentPage[\'' + sheetName + '\'] - 1)">上一页</button>';
                    mergedDataHTML += '        <span class="page-info" id="pageInfo-' + sheetName + '">第 <span id="current-' + sheetName + '">' + currentPage[sheetName] + '</span> 页，共 <span id="total-' + sheetName + '">' + totalPages[sheetName] + '</span> 页</span>';
                    mergedDataHTML += '        <button class="page-btn" id="nextPage-' + sheetName + '" onclick="changePage(\'' + sheetName + '\', currentPage[\'' + sheetName + '\'] + 1)">下一页</button>';
                    mergedDataHTML += '        <button class="page-btn" id="lastPage-' + sheetName + '" onclick="changePage(\'' + sheetName + '\', totalPages[\'' + sheetName + '\'])">末页</button>';
                    mergedDataHTML += '    </div>';
                    mergedDataHTML += '</div>';
                }
                
                mergedDataHTML += '</div>'; // 关闭 tab-content
            });
            
            mergedDataHTML += '</div>'; // 关闭 tab-contents
            mergedDataHTML += '</div>'; // 关闭 tab-container
            mergedDataHTML += '</div>'; // 关闭 mergedDataContainer
            
            // 将生成的表格HTML添加到页面中
            tableContainer.innerHTML = mergedDataHTML;
        }
        
 
        /**
         * 切换标签页
         * @param {string} sheetName - 工作表名称
         * @param {string} type - 标签页类型（'original' 或 'merged'）
         */
        
        /**
         * 更新搜索结果提示信息
         * @param {string} sheetName - 工作表名称
         */
        function updateSearchResultInfo(sheetName) {
            // 获取搜索词
            const searchTerm = document.getElementById('searchInput').value.trim();
            
            // 如果没有搜索词，清除结果提示
            if (!searchTerm) {
                document.getElementById('result').innerHTML = '';
                return;
            }
            
            // 计算当前工作表的匹配记录数量
            let matchCount = 0;
            if (originalMergedData && originalMergedData[sheetName]) {
                originalMergedData[sheetName].forEach(row => {
                    const model = row['型号'] ? row['型号'].toString() : '';
                    const batch = row['批次'] ? row['批次'].toString() : '';
                    
                    const modelMatch = model.toLowerCase().includes(searchTerm.toLowerCase());
                    const batchMatch = batch.toLowerCase().includes(searchTerm.toLowerCase());
                    
                    if (modelMatch || batchMatch) {
                        matchCount++;
                    }
                });
            }
            
            // 更新结果提示信息
            const resultElement = document.getElementById('result');
            if (matchCount > 0) {
                resultElement.innerHTML = `<p class="success">在工作表 "${sheetName}" 中找到 ${matchCount} 条匹配记录</p>`;
            } else {
                resultElement.innerHTML = `<p class="error">在工作表 "${sheetName}" 中未找到匹配的记录</p>`;
            }
        }
        
        /**
         * 改变每页显示条数
         * @param {string} sheetName - 工作表名称
         */
        function changePageSize(sheetName) {
            const selectElement = document.getElementById('pageSizeSelect-' + sheetName);
            pageSize[sheetName] = parseInt(selectElement.value);
            currentPage[sheetName] = 1; // 重置到第一页
            
            // 重新应用搜索过滤
            const searchTerm = document.getElementById('searchInput').value.trim();
            if (searchTerm) {
                // 创建搜索结果的副本 - 在所有工作表中搜索
                const filteredData = {};
                
                // 在所有工作表中搜索
                for (const name in originalMergedData) {
                    const sheetData = originalMergedData[name];
                    filteredData[name] = [];
                    
                    // 过滤数据 - 只在型号和批次字段中搜索
                    sheetData.forEach(row => {
                        // 检查型号和批次字段是否包含搜索词（不区分大小写）
                        const model = row['型号'] ? row['型号'].toString() : '';
                        const batch = row['批次'] ? row['批次'].toString() : '';
                        
                        const modelMatch = model.toLowerCase().includes(searchTerm.toLowerCase());
                        const batchMatch = batch.toLowerCase().includes(searchTerm.toLowerCase());
                        
                        // 如果满足搜索条件，则添加到结果中
                        if (modelMatch || batchMatch) {
                            filteredData[name].push(row);
                        }
                    });
                }
                
                // 更新当前工作表的总页数
                totalPages[sheetName] = Math.ceil(filteredData[sheetName].length / pageSize[sheetName]);
                
                // 重新渲染表格
                renderMergedDataBelow(filteredData);
            } else {
                totalPages[sheetName] = Math.ceil(originalMergedData[sheetName].length / pageSize[sheetName]);
                renderMergedDataBelow(originalMergedData);
            }
        }
        
        /**
         * 切换页面
         * @param {string} sheetName - 工作表名称
         * @param {number} page - 页码
         */
        function changePage(sheetName, page) {
            // 边界检查
            if (page < 1 || page > totalPages[sheetName]) {
                return;
            }
            
            currentPage[sheetName] = page;
            renderMergedDataBelow(originalMergedData);
        }
        function switchTab(sheetName, type = 'original') {
            // 记录当前激活的工作表
            activeSheetName = sheetName;
            
            let tabButtons, tabContents;
            
            if (type === 'merged') {
                const mergedDataContainer = document.getElementById('mergedDataContainer');
                if (!mergedDataContainer) return;
                tabButtons = mergedDataContainer.querySelectorAll('.tab-button');
                tabContents = mergedDataContainer.querySelectorAll('.tab-content');
            } else {
                tabButtons = document.querySelectorAll('.tab-button');
                tabContents = document.querySelectorAll('.tab-content');
            }
            
            // 移除所有激活状态
            tabButtons.forEach(button => {
                button.classList.remove('active');
            });
            tabContents.forEach(content => {
                content.classList.remove('active');
            });
            
            // 激活当前标签页
            const activeButton = Array.from(tabButtons).find(button => button.textContent.startsWith(sheetName + ' ('));
            if (activeButton) {
                activeButton.classList.add('active');
            }
            
            const activeContent = document.getElementById(`tab-${type === 'merged' ? 'merged-' : ''}${sheetName}`);
            if (activeContent) {
                activeContent.classList.add('active');
            }
            
            // 更新搜索结果提示信息
            updateSearchResultInfo(sheetName);
        }
        
    </script>
</body>
</html>
